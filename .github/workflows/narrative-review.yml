name: Narrative Chapter Review (PR)

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - "02_NARRATIVE/book_01/CHAPTERS/**"
      - "02_NARRATIVE/book_01/OUTLINES/CHAPTER_OUTLINES/**"

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: narrative-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

env:
  MODEL_DEFAULT: "gpt-5-mini"
  MODEL_DEEP: "gpt-5.2"
  DEEP_LABEL: "deep-review"
  TOKEN_LIMIT: "4000"
  TARGET_CHUNK_TOKENS: "3500"
  TARGET_BATCH_TOKENS: "7000"
  CANON_DIGEST_PATH: "00_CANON/_DIGEST.md"
  CANON_DIGEST_MAX_CHARS: "45000"
  MAX_OUTPUT_TOKENS_PER_BATCH: "1400"

jobs:
  narrative-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Select model
        id: model
        run: |
          LABELS='${{ toJson(github.event.pull_request.labels) }}'
          MODEL="${{ env.MODEL_DEFAULT }}"
          if echo '${{ toJson(github.event.pull_request.labels) }}' | grep -q '"name":"${{ env.DEEP_LABEL }}"'; then
            MODEL="${{ env.MODEL_DEEP }}"
          fi
          echo "model=$MODEL" >> "$GITHUB_OUTPUT"

      - name: Collect files
        id: collect
        run: |
          CHANGED=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- "02_NARRATIVE/book_01/CHAPTERS/**" "02_NARRATIVE/book_01/OUTLINES/CHAPTER_OUTLINES/**" || true)
          if [ -z "$CHANGED" ]; then
            echo "has_files=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "has_files=true" >> "$GITHUB_OUTPUT"
          mkdir -p .tmp_narrative_review
          echo "$CHANGED" > .tmp_narrative_review/files.txt
          
          # Create Python script
          cat > .tmp_narrative_review/chunk.py << 'PYTHONSCRIPT'
          import os, json, re, pathlib
          
          with open(".tmp_narrative_review/files.txt") as f:
              files = [l.strip() for l in f if l.strip()]
          
          TOKEN_LIMIT = int(os.environ.get("TOKEN_LIMIT", "4000"))
          TARGET_CHUNK = int(os.environ.get("TARGET_CHUNK_TOKENS", "3500"))
          TARGET_BATCH = int(os.environ.get("TARGET_BATCH_TOKENS", "7000"))
          outdir = pathlib.Path(".tmp_narrative_review")
          
          def est_tokens(s): return max(1, len(s) // 4)
          def sanitize(n): return re.sub(r"[^A-Za-z0-9._-]+", "_", n)
          
          def chunk_text(text):
              if est_tokens(text) <= TOKEN_LIMIT: return [text]
              lines, chunks, buf, buf_tok = text.splitlines(keepends=True), [], [], 0
              for ln in lines:
                  ln_tok = est_tokens(ln)
                  is_brk = ln.strip() == "" or ln.lstrip().startswith("#")
                  if buf and buf_tok + ln_tok > TARGET_CHUNK and is_brk:
                      chunks.append("".join(buf).strip("\n") + "\n")
                      buf, buf_tok = [], 0
                  buf.append(ln)
                  buf_tok += ln_tok
                  if buf_tok > TOKEN_LIMIT:
                      chunks.append("".join(buf).strip("\n") + "\n")
                      buf, buf_tok = [], 0
              if buf: chunks.append("".join(buf).strip("\n") + "\n")
              return [c for c in chunks if c.strip()] or [text]
          
          manifest = []
          for f in files:
              p = pathlib.Path(f)
              if not p.exists(): continue
              text = p.read_text(encoding="utf-8", errors="ignore")
              parts = chunk_text(text)
              for i, part in enumerate(parts, 1):
                  cp = outdir / f"{sanitize(p.as_posix())}__chunk{i:02d}.txt"
                  cp.write_text(part, encoding="utf-8")
                  manifest.append({"file": p.as_posix(), "chunk": i, "chunk_count": len(parts),
                                   "chunk_path": cp.as_posix(), "est_tokens": est_tokens(part),
                                   "est_tokens_total": est_tokens(text)})
          
          batches = []
          for f in sorted(set(c["file"] for c in manifest)):
              chs = sorted([c for c in manifest if c["file"] == f], key=lambda x: x["chunk"])
              batch, batch_tok, batch_idx = [], 0, 1
              for c in chs:
                  if batch and batch_tok + c["est_tokens"] > TARGET_BATCH:
                      batches.append({"file": f, "batch": batch_idx, "chunks": batch, "batch_est_tokens": batch_tok})
                      batch, batch_tok, batch_idx = [], 0, batch_idx + 1
                  batch.append({"chunk": c["chunk"], "chunk_count": c["chunk_count"], 
                                "chunk_path": c["chunk_path"], "est_tokens": c["est_tokens"]})
                  batch_tok += c["est_tokens"]
              if batch:
                  batches.append({"file": f, "batch": batch_idx, "chunks": batch, "batch_est_tokens": batch_tok})
          
          (outdir / "batches.json").write_text(json.dumps(batches, indent=2))
          print(f"Files: {len(files)}, Batches: {len(batches)}")
          PYTHONSCRIPT
          
          python3 .tmp_narrative_review/chunk.py

      - name: Run AI review
        if: steps.collect.outputs.has_files == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          MODEL: ${{ steps.model.outputs.model }}
          MAX_TOKENS: ${{ env.MAX_OUTPUT_TOKENS_PER_BATCH }}
        run: |
          PR="${{ github.event.pull_request.number }}"
          COMMENT=".tmp_narrative_review/review_comment.md"
          
          echo "<!-- NARRATIVE_REVIEW -->" > "$COMMENT"
          echo "# Narrative Review (AI) - DEBUG MODE" >> "$COMMENT"
          echo "" >> "$COMMENT"
          echo "- Model: \`${MODEL}\`" >> "$COMMENT"
          echo "- PR: #${PR}" >> "$COMMENT"
          echo "" >> "$COMMENT"
          
          BATCH_COUNT=$(jq 'length' .tmp_narrative_review/batches.json)
          
          for idx in $(seq 0 $((BATCH_COUNT-1))); do
            FILE=$(jq -r ".[$idx].file" .tmp_narrative_review/batches.json)
            BATCH=$(jq -r ".[$idx].batch" .tmp_narrative_review/batches.json)
            
            # Build content from chunks using temp file (avoids string escaping issues)
            TEMPFILE=".tmp_narrative_review/batch_${idx}_content.txt"
            > "$TEMPFILE"
            
            CHUNK_COUNT=$(jq -r ".[$idx].chunks | length" .tmp_narrative_review/batches.json)
            for cidx in $(seq 0 $((CHUNK_COUNT-1))); do
              CPATH=$(jq -r ".[$idx].chunks[$cidx].chunk_path" .tmp_narrative_review/batches.json)
              CNUM=$(jq -r ".[$idx].chunks[$cidx].chunk" .tmp_narrative_review/batches.json)
              CTOT=$(jq -r ".[$idx].chunks[$cidx].chunk_count" .tmp_narrative_review/batches.json)
              echo "" >> "$TEMPFILE"
              echo "---" >> "$TEMPFILE"
              echo "[CHUNK ${CNUM}/${CTOT}]" >> "$TEMPFILE"
              echo "" >> "$TEMPFILE"
              cat "$CPATH" >> "$TEMPFILE"
            done
            
            # Build prompt safely using jq --arg (auto-escapes)
            PROMPT_PREFIX="Du bist Lektor fÃ¼r ein deutsches YA-Fantasy-Franchise. Reviewe diesen Text.
          Ausgabe: 1) Kurzfazit 2) BLOCKER 3) WICHTIG 4) NITPICK 5) Fragen
          
          Datei: ${FILE} (Batch ${BATCH})"
            
            CONTENT=$(cat "$TEMPFILE")
            
            PAYLOAD=$(jq -n \
              --arg m "$MODEL" \
              --arg prefix "$PROMPT_PREFIX" \
              --arg content "$CONTENT" \
              --argjson maxtok "$MAX_TOKENS" \
              '{model:$m, input:[{role:"user",content:[{type:"input_text",text:($prefix + "\n\n" + $content)}]}], max_output_tokens:$maxtok}')
            
            RESP=$(curl -w "\n%{http_code}" -sS \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -H "Content-Type: application/json" \
              https://api.openai.com/v1/responses \
              -d "$PAYLOAD")
            
            HTTP_CODE=$(echo "$RESP" | tail -1)
            BODY=$(echo "$RESP" | sed '$d')
            
            if [ "$HTTP_CODE" -ge 400 ]; then
              ERR=$(echo "$BODY" | jq -r '.error.message // "Unknown error"')
              echo "" >> "$COMMENT"
              echo "## ${FILE} â€” Batch ${BATCH}" >> "$COMMENT"
              echo "" >> "$COMMENT"
              echo "**Error** (HTTP ${HTTP_CODE}): ${ERR}" >> "$COMMENT"
              continue
            fi
            
            # DEBUG: Show the complete API response
            echo "" >> "$COMMENT"
            echo "## ${FILE} â€” Batch ${BATCH}" >> "$COMMENT"
            echo "" >> "$COMMENT"
            echo "### ðŸ” DEBUG: Complete API Response" >> "$COMMENT"
            echo "" >> "$COMMENT"
            echo '```json' >> "$COMMENT"
            echo "$BODY" | jq '.' >> "$COMMENT"
            echo '```' >> "$COMMENT"
            echo "" >> "$COMMENT"
            
            # Try to extract the output
            OUT=$(echo "$BODY" | jq -r '.output_text // ([.output[]?.content[]? | select(.type=="text") | .text] | join("\n")) // "No output"')
            echo "### Parsed Output:" >> "$COMMENT"
            echo "" >> "$COMMENT"
            echo "$OUT" >> "$COMMENT"
          done

      - name: Post comment
        if: steps.collect.outputs.has_files == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR="${{ github.event.pull_request.number }}"
          REPO="${{ github.repository }}"
          FILE=".tmp_narrative_review/review_comment.md"
          
          [ ! -f "$FILE" ] && exit 0
          
          # Read comment body
          BODY=$(cat "$FILE")
          
          # Find existing comment
          EXISTING=$(gh api "repos/$REPO/issues/$PR/comments" --paginate | jq -r '.[] | select(.body | contains("<!-- NARRATIVE_REVIEW -->")) | .id' | head -1 || true)
          
          # Build JSON payload with jq (handles escaping)
          PAYLOAD=$(jq -n --arg body "$BODY" '{body:$body}')
          
          if [ -n "$EXISTING" ]; then
            gh api -X PATCH "repos/$REPO/issues/comments/$EXISTING" --input - <<< "$PAYLOAD"
          else
            gh api -X POST "repos/$REPO/issues/$PR/comments" --input - <<< "$PAYLOAD"
          fi

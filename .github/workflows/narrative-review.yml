name: Narrative Chapter Review (PR)

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - "02_NARRATIVE/book_01/CHAPTERS/**"
      - "02_NARRATIVE/book_01/OUTLINES/CHAPTER_OUTLINES/**"

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: narrative-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

env:
  MODEL_DEFAULT: "gpt-5-mini"
  MODEL_DEEP: "gpt-5.2"
  DEEP_LABEL: "deep-review"
  TOKEN_LIMIT: "4000"
  TARGET_CHUNK_TOKENS: "3500"
  TARGET_BATCH_TOKENS: "7000"
  CANON_DIGEST_PATH: "00_CANON/_DIGEST.md"
  CANON_DIGEST_MAX_CHARS: "45000"
  MAX_OUTPUT_TOKENS_PER_BATCH: "2500"

jobs:
  narrative-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Select model
        id: model
        run: |
          LABELS='${{ toJson(github.event.pull_request.labels) }}'
          MODEL="${{ env.MODEL_DEFAULT }}"
          if echo '${{ toJson(github.event.pull_request.labels) }}' | grep -q '"name":"${{ env.DEEP_LABEL }}"'; then
            MODEL="${{ env.MODEL_DEEP }}"
          fi
          echo "model=$MODEL" >> "$GITHUB_OUTPUT"

      - name: Load Canon Digest
        id: canon
        run: |
          DIGEST_PATH="${{ env.CANON_DIGEST_PATH }}"
          MAX_CHARS="${{ env.CANON_DIGEST_MAX_CHARS }}"
          
          if [ -f "$DIGEST_PATH" ]; then
            CANON_CONTENT=$(head -c "$MAX_CHARS" "$DIGEST_PATH")
            echo "has_canon=true" >> "$GITHUB_OUTPUT"
            echo "$CANON_CONTENT" > .tmp_canon_digest.txt
            echo "✅ Canon-Digest geladen ($(wc -c < .tmp_canon_digest.txt) bytes)"
          else
            echo "has_canon=false" >> "$GITHUB_OUTPUT"
            echo "⚠️ Kein Canon-Digest gefunden"
          fi

      - name: Collect files
        id: collect
        run: |
          CHANGED=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- "02_NARRATIVE/book_01/CHAPTERS/**" "02_NARRATIVE/book_01/OUTLINES/CHAPTER_OUTLINES/**" || true)
          if [ -z "$CHANGED" ]; then
            echo "has_files=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "has_files=true" >> "$GITHUB_OUTPUT"
          mkdir -p .tmp_narrative_review
          echo "$CHANGED" > .tmp_narrative_review/files.txt
          
          cat > .tmp_narrative_review/chunk.py << 'PYSCRIPT'
          import os, json, re, pathlib
          
          with open(".tmp_narrative_review/files.txt") as f:
              files = [l.strip() for l in f if l.strip()]
          
          TOKEN_LIMIT = int(os.environ.get("TOKEN_LIMIT", "4000"))
          TARGET_CHUNK = int(os.environ.get("TARGET_CHUNK_TOKENS", "3500"))
          TARGET_BATCH = int(os.environ.get("TARGET_BATCH_TOKENS", "7000"))
          outdir = pathlib.Path(".tmp_narrative_review")
          
          def est_tokens(s): return max(1, len(s) // 4)
          def sanitize(n): return re.sub(r"[^A-Za-z0-9._-]+", "_", n)
          
          def chunk_text(text):
              if est_tokens(text) <= TOKEN_LIMIT: return [text]
              lines, chunks, buf, buf_tok = text.splitlines(keepends=True), [], [], 0
              for ln in lines:
                  ln_tok = est_tokens(ln)
                  is_brk = ln.strip() == "" or ln.lstrip().startswith("#")
                  if buf and buf_tok + ln_tok > TARGET_CHUNK and is_brk:
                      chunks.append("".join(buf).strip("\n") + "\n")
                      buf, buf_tok = [], 0
                  buf.append(ln)
                  buf_tok += ln_tok
                  if buf_tok > TOKEN_LIMIT:
                      chunks.append("".join(buf).strip("\n") + "\n")
                      buf, buf_tok = [], 0
              if buf: chunks.append("".join(buf).strip("\n") + "\n")
              return [c for c in chunks if c.strip()] or [text]
          
          manifest = []
          for f in files:
              p = pathlib.Path(f)
              if not p.exists(): continue
              text = p.read_text(encoding="utf-8", errors="ignore")
              parts = chunk_text(text)
              for i, part in enumerate(parts, 1):
                  cp = outdir / f"{sanitize(p.as_posix())}__chunk{i:02d}.txt"
                  cp.write_text(part, encoding="utf-8")
                  manifest.append({"file": p.as_posix(), "chunk": i, "chunk_count": len(parts),
                                   "chunk_path": cp.as_posix(), "est_tokens": est_tokens(part),
                                   "est_tokens_total": est_tokens(text)})
          
          batches = []
          for f in sorted(set(c["file"] for c in manifest)):
              chs = sorted([c for c in manifest if c["file"] == f], key=lambda x: x["chunk"])
              batch, batch_tok, batch_idx = [], 0, 1
              for c in chs:
                  if batch and batch_tok + c["est_tokens"] > TARGET_BATCH:
                      batches.append({"file": f, "batch": batch_idx, "chunks": batch, "batch_est_tokens": batch_tok})
                      batch, batch_tok, batch_idx = [], 0, batch_idx + 1
                  batch.append({"chunk": c["chunk"], "chunk_count": c["chunk_count"], 
                                "chunk_path": c["chunk_path"], "est_tokens": c["est_tokens"]})
                  batch_tok += c["est_tokens"]
              if batch:
                  batches.append({"file": f, "batch": batch_idx, "chunks": batch, "batch_est_tokens": batch_tok})
          
          (outdir / "batches.json").write_text(json.dumps(batches, indent=2))
          print(f"Files: {len(files)}, Batches: {len(batches)}")
          PYSCRIPT
          
          python3 .tmp_narrative_review/chunk.py

      - name: Create prompt builder
        run: |
          cat > .tmp_narrative_review/build_prompt.py << 'PYSCRIPT'
          import sys, pathlib
          
          output_file = sys.argv[1]
          file_path = sys.argv[2]
          batch_num = sys.argv[3]
          content_file = sys.argv[4]
          canon_file = sys.argv[5] if len(sys.argv) > 5 and sys.argv[5] != "NONE" else None
          
          parts = []
          parts.append("Du bist der Lead Story Editor fuer MystiMons, ein deutsches YA-Fantasy-Franchise.\n\n")
          parts.append("DEINE AUFGABE:\n")
          parts.append("Reviewe den folgenden Text auf:\n")
          parts.append("1. Canon-Konsistenz (gegen Pillars & Laws pruefen)\n")
          parts.append("2. Narrative Qualitaet (Struktur, Pacing, Emotion)\n")
          parts.append("3. YA-Voice Authentizitaet (14-jaehriger Protagonist Finn)\n")
          parts.append("4. Worldbuilding-Kohaerenz (Magiesystem, Terminologie)\n\n")
          parts.append("PROJEKT-KONTEXT:\n")
          parts.append("- Franchise: MystiMons (YA Fantasy + TCG + App)\n")
          parts.append("- Buch 1: Aetheria: Der Klang der Stille\n")
          parts.append("- Protagonist: Finn Alder, 14 Jahre\n")
          parts.append("  * Kann ALLE Resonanten hoeren (einzigartige Gabe)\n")
          parts.append("  * Kann sich mit KEINEM binden (sein Fluch)\n")
          parts.append("  * Sucht seinen verschwundenen Bruder Theo\n")
          parts.append("- Kernbotschaft: Du wirst nicht staerker allein. Du wirst staerker zusammen.\n")
          parts.append("- Zielgruppe: 12-18 Jahre (Kern)\n")
          
          if canon_file and pathlib.Path(canon_file).exists():
              parts.append("\nCANON-REGELN (UNVERHANDELBAR):\n\n")
              parts.append(pathlib.Path(canon_file).read_text(encoding='utf-8'))
          
          parts.append("\nREVIEW-STRUKTUR (PFLICHT):\n\n")
          parts.append("Strukturiere dein Review EXAKT so:\n\n")
          parts.append("1) Kurzfazit\n")
          parts.append("Ein knapper Absatz: Was funktioniert? Was ist das Kernproblem?\n\n")
          parts.append("2) BLOCKER (Dinge, die vor dem Schreiben geklaert/behoben werden muessen)\n")
          parts.append("- Aufzaehlungsliste\n")
          parts.append("- Jeder Punkt: Was ist das Problem? Warum blockiert es?\n")
          parts.append("- Wenn gegen Pillars/Laws verstoesst: Explizit benennen (z.B. Verstoesst gegen PIL-001)\n\n")
          parts.append("3) WICHTIG (Wichtige Verbesserungen, die die Szenen deutlich staerker machen)\n")
          parts.append("- Aufzaehlungsliste\n")
          parts.append("- Konkrete Verbesserungsvorschlaege\n")
          parts.append("- Priorisiert nach Impact\n\n")
          parts.append("4) NITPICK (Stil- und Detailanmerkungen)\n")
          parts.append("- Aufzaehlungsliste\n")
          parts.append("- Feinschliff, nicht kritisch\n")
          parts.append("- Wortwahl, Tempo, kleine Inkonsistenzen\n\n")
          parts.append("5) Fragen (fuer Autor/Worldbuilder)\n")
          parts.append("- Nummerierte Liste\n")
          parts.append("- Klaerungsfragen zu Worldbuilding, Charaktermotivation, etc.\n")
          parts.append("- Helfen, Plot-Holes zu vermeiden\n\n")
          parts.append("Schlussbemerkung (kurz):\n")
          parts.append("Gesamteindruck + naechste Schritte\n\n")
          parts.append("REVIEW-KRITERIEN:\n\n")
          parts.append("Canon-Konsistenz:\n")
          parts.append("- Pruefe JEDEN Plot-Punkt gegen die 5 Pillars\n")
          parts.append("- Pruefe gegen die 10 Laws\n")
          parts.append("- Terminology-Check (Naming Bible)\n\n")
          parts.append("YA-Voice (Finn, 14):\n")
          parts.append("- Authentisch, nicht kindisch\n")
          parts.append("- Innerer Monolog: reflektiert, manchmal unsicher\n")
          parts.append("- Humor: trocken, nicht albern\n")
          parts.append("- Zeigen statt Erzaehlen (keine Filterworte: er fuehlte)\n\n")
          parts.append("Narrative Qualitaet:\n")
          parts.append("- Szenenstruktur: Ziel -> Konflikt -> Veraenderung\n")
          parts.append("- Pacing: Wechsel zwischen Action und Reflexion\n")
          parts.append("- Emotionale Stakes: Klar und nachvollziehbar\n")
          parts.append("- Hooks: Kapitelenden ziehen weiter\n\n")
          parts.append("Worldbuilding:\n")
          parts.append("- Magiesystem-Regeln konsistent?\n")
          parts.append("- Resonanz-Mechanik klar?\n")
          parts.append("- Gesellschafts-Logik plausibel?\n\n")
          parts.append("---\n\n")
          parts.append(f"DATEI: {file_path} (Batch {batch_num})\n\n")
          parts.append("ZU REVIEWENDER TEXT:\n\n")
          parts.append(pathlib.Path(content_file).read_text(encoding='utf-8'))
          
          pathlib.Path(output_file).write_text(''.join(parts), encoding='utf-8')
          PYSCRIPT

      - name: Run AI review
        if: steps.collect.outputs.has_files == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          MODEL: ${{ steps.model.outputs.model }}
          MAX_TOKENS: ${{ env.MAX_OUTPUT_TOKENS_PER_BATCH }}
          HAS_CANON: ${{ steps.canon.outputs.has_canon }}
        run: |
          PR="${{ github.event.pull_request.number }}"
          COMMENT=".tmp_narrative_review/review_comment.md"
          
          echo "<!-- NARRATIVE_REVIEW -->" > "$COMMENT"
          echo "# Narrative Review (AI)" >> "$COMMENT"
          echo "" >> "$COMMENT"
          echo "- Model: \`${MODEL}\`" >> "$COMMENT"
          echo "- PR: #${PR}" >> "$COMMENT"
          if [ "$HAS_CANON" = "true" ]; then
            echo "- Canon-Kontext: ✅ Aktiv" >> "$COMMENT"
          fi
          echo "" >> "$COMMENT"
          
          BATCH_COUNT=$(jq 'length' .tmp_narrative_review/batches.json)
          
          for idx in $(seq 0 $((BATCH_COUNT-1))); do
            FILE=$(jq -r ".[$idx].file" .tmp_narrative_review/batches.json)
            BATCH=$(jq -r ".[$idx].batch" .tmp_narrative_review/batches.json)
            
            # Build content from chunks using temp file (avoids string escaping issues)
            TEMPFILE=".tmp_narrative_review/batch_${idx}_content.txt"
            > "$TEMPFILE"
            
            CHUNK_COUNT=$(jq -r ".[$idx].chunks | length" .tmp_narrative_review/batches.json)
            for cidx in $(seq 0 $((CHUNK_COUNT-1))); do
              CPATH=$(jq -r ".[$idx].chunks[$cidx].chunk_path" .tmp_narrative_review/batches.json)
              CNUM=$(jq -r ".[$idx].chunks[$cidx].chunk" .tmp_narrative_review/batches.json)
              CTOT=$(jq -r ".[$idx].chunks[$cidx].chunk_count" .tmp_narrative_review/batches.json)
              echo "" >> "$TEMPFILE"
              echo "---" >> "$TEMPFILE"
              echo "[CHUNK ${CNUM}/${CTOT}]" >> "$TEMPFILE"
              echo "" >> "$TEMPFILE"
              cat "$CPATH" >> "$TEMPFILE"
            done
            
            # Build prompt safely using jq --arg (auto-escapes)
            PROMPT_PREFIX="Du bist Lektor für ein deutsches YA-Fantasy-Franchise. Reviewe diesen Text.
          Ausgabe: 1) Kurzfazit 2) BLOCKER 3) WICHTIG 4) NITPICK 5) Fragen
          
          Datei: ${FILE} (Batch ${BATCH})"
            
            CONTENT=$(cat "$TEMPFILE")
            
            PAYLOAD=$(jq -n \
              --arg m "$MODEL" \
              --arg prefix "$PROMPT_PREFIX" \
              --arg content "$CONTENT" \
              --argjson maxtok "$MAX_TOKENS" \
              '{model:$m, input:[{role:"user",content:[{type:"input_text",text:($prefix + "\n\n" + $content)}]}], max_output_tokens:$maxtok}')
            PROMPT_TEMP=".tmp_narrative_review/prompt_${idx}.txt"
            CANON_ARG="NONE"
            if [ "$HAS_CANON" = "true" ]; then
              CANON_ARG=".tmp_canon_digest.txt"
            fi
            python3 .tmp_narrative_review/build_prompt.py "$PROMPT_TEMP" "$FILE" "$BATCH" "$TEMPFILE" "$CANON_ARG"
            
            CONTENT=$(cat "$PROMPT_TEMP")
            
            PAYLOAD=$(jq -n \
              --arg m "$MODEL" \
              --arg content "$CONTENT" \
              --argjson maxtok "$MAX_TOKENS" \
              '{model:$m, input:[{role:"user",content:[{type:"input_text",text:$content}]}], max_output_tokens:$maxtok}')
            
            RESP=$(curl -w "\n%{http_code}" -sS \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -H "Content-Type: application/json" \
              https://api.openai.com/v1/responses \
              -d "$PAYLOAD")
            
            HTTP_CODE=$(echo "$RESP" | tail -1)
            BODY=$(echo "$RESP" | sed '$d')
            
            if [ "$HTTP_CODE" -ge 400 ]; then
              ERR=$(echo "$BODY" | jq -r '.error.message // "Unknown error"')
              echo "" >> "$COMMENT"
              echo "## ${FILE} — Batch ${BATCH}" >> "$COMMENT"
              echo "" >> "$COMMENT"
              echo "**Error** (HTTP ${HTTP_CODE}): ${ERR}" >> "$COMMENT"
              continue
            fi
            
            # FIXED: Correct parsing for output_text type
            OUT=$(echo "$BODY" | jq -r '[.output[]? | select(.type=="message") | .content[]? | select(.type=="output_text") | .text] | join("\n\n")')
            
            # Handle incomplete responses
            OUT=$(echo "$BODY" | jq -r '[.output[]? | select(.type=="message") | .content[]? | select(.type=="output_text") | .text] | join("\n\n")')
            
            STATUS=$(echo "$BODY" | jq -r '.status // "complete"')
            if [ "$STATUS" = "incomplete" ]; then
              REASON=$(echo "$BODY" | jq -r '.incomplete_details.reason // "unknown"')
              echo "" >> "$COMMENT"
              echo "## ${FILE} — Batch ${BATCH}" >> "$COMMENT"
              echo "" >> "$COMMENT"
              echo "> ⚠️ **Response incomplete** (reason: ${REASON})" >> "$COMMENT"
              echo "" >> "$COMMENT"
              echo "$OUT" >> "$COMMENT"
            else
              echo "" >> "$COMMENT"
              echo "## ${FILE} — Batch ${BATCH}" >> "$COMMENT"
              echo "" >> "$COMMENT"
              echo "$OUT" >> "$COMMENT"
            fi
          done

      - name: Post comment
        if: steps.collect.outputs.has_files == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR="${{ github.event.pull_request.number }}"
          REPO="${{ github.repository }}"
          FILE=".tmp_narrative_review/review_comment.md"
          
          [ ! -f "$FILE" ] && exit 0
          
          # Read comment body
          BODY=$(cat "$FILE")
          
          # Find existing comment
          EXISTING=$(gh api "repos/$REPO/issues/$PR/comments" --paginate | jq -r '.[] | select(.body | contains("<!-- NARRATIVE_REVIEW -->")) | .id' | head -1 || true)
          
          # Build JSON payload with jq (handles escaping)
          BODY=$(cat "$FILE")
          
          EXISTING=$(gh api "repos/$REPO/issues/$PR/comments" --paginate | jq -r '.[] | select(.body | contains("<!-- NARRATIVE_REVIEW -->")) | .id' | head -1 || true)
          
          PAYLOAD=$(jq -n --arg body "$BODY" '{body:$body}')
          
          if [ -n "$EXISTING" ]; then
            gh api -X PATCH "repos/$REPO/issues/comments/$EXISTING" --input - <<< "$PAYLOAD"
          else
            gh api -X POST "repos/$REPO/issues/$PR/comments" --input - <<< "$PAYLOAD"
          fi

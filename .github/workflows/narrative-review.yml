name: Narrative Chapter Review (PR)

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - "02_NARRATIVE/book_01/CHAPTERS/**"
      - "02_NARRATIVE/book_01/OUTLINES/CHAPTER_OUTLINES/**"

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: narrative-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

env:
  MODEL_DEFAULT: "gpt-5-mini"
  MODEL_DEEP: "gpt-5.2"
  DEEP_LABEL: "deep-review"
  TOKEN_LIMIT: "4000"
  TARGET_CHUNK_TOKENS: "3500"
  TARGET_BATCH_TOKENS: "7000"
  CANON_DIGEST_PATH: "00_CANON/_DIGEST.md"
  CANON_DIGEST_MAX_CHARS: "45000"
  MAX_OUTPUT_TOKENS_PER_BATCH: "2500"

jobs:
  narrative-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Select model
        id: model
        run: |
          LABELS='${{ toJson(github.event.pull_request.labels) }}'
          MODEL="${{ env.MODEL_DEFAULT }}"
          if echo '${{ toJson(github.event.pull_request.labels) }}' | grep -q '"name":"${{ env.DEEP_LABEL }}"'; then
            MODEL="${{ env.MODEL_DEEP }}"
          fi
          echo "model=$MODEL" >> "$GITHUB_OUTPUT"

      - name: Load Canon Digest
        id: canon
        run: |
          DIGEST_PATH="${{ env.CANON_DIGEST_PATH }}"
          MAX_CHARS="${{ env.CANON_DIGEST_MAX_CHARS }}"
          
          if [ -f "$DIGEST_PATH" ]; then
            CANON_CONTENT=$(head -c "$MAX_CHARS" "$DIGEST_PATH")
            echo "has_canon=true" >> "$GITHUB_OUTPUT"
            echo "$CANON_CONTENT" > .tmp_canon_digest.txt
            echo "✅ Canon-Digest geladen ($(wc -c < .tmp_canon_digest.txt) bytes)"
          else
            echo "has_canon=false" >> "$GITHUB_OUTPUT"
            echo "⚠️ Kein Canon-Digest gefunden"
          fi

      - name: Collect files
        id: collect
        run: |
          CHANGED=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- "02_NARRATIVE/book_01/CHAPTERS/**" "02_NARRATIVE/book_01/OUTLINES/CHAPTER_OUTLINES/**" || true)
          if [ -z "$CHANGED" ]; then
            echo "has_files=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "has_files=true" >> "$GITHUB_OUTPUT"
          mkdir -p .tmp_narrative_review
          echo "$CHANGED" > .tmp_narrative_review/files.txt
          
          # Create Python script
          cat > .tmp_narrative_review/chunk.py << 'PYTHONSCRIPT'
          import os, json, re, pathlib
          
          with open(".tmp_narrative_review/files.txt") as f:
              files = [l.strip() for l in f if l.strip()]
          
          TOKEN_LIMIT = int(os.environ.get("TOKEN_LIMIT", "4000"))
          TARGET_CHUNK = int(os.environ.get("TARGET_CHUNK_TOKENS", "3500"))
          TARGET_BATCH = int(os.environ.get("TARGET_BATCH_TOKENS", "7000"))
          outdir = pathlib.Path(".tmp_narrative_review")
          
          def est_tokens(s): return max(1, len(s) // 4)
          def sanitize(n): return re.sub(r"[^A-Za-z0-9._-]+", "_", n)
          
          def chunk_text(text):
              if est_tokens(text) <= TOKEN_LIMIT: return [text]
              lines, chunks, buf, buf_tok = text.splitlines(keepends=True), [], [], 0
              for ln in lines:
                  ln_tok = est_tokens(ln)
                  is_brk = ln.strip() == "" or ln.lstrip().startswith("#")
                  if buf and buf_tok + ln_tok > TARGET_CHUNK and is_brk:
                      chunks.append("".join(buf).strip("\n") + "\n")
                      buf, buf_tok = [], 0
                  buf.append(ln)
                  buf_tok += ln_tok
                  if buf_tok > TOKEN_LIMIT:
                      chunks.append("".join(buf).strip("\n") + "\n")
                      buf, buf_tok = [], 0
              if buf: chunks.append("".join(buf).strip("\n") + "\n")
              return [c for c in chunks if c.strip()] or [text]
          
          manifest = []
          for f in files:
              p = pathlib.Path(f)
              if not p.exists(): continue
              text = p.read_text(encoding="utf-8", errors="ignore")
              parts = chunk_text(text)
              for i, part in enumerate(parts, 1):
                  cp = outdir / f"{sanitize(p.as_posix())}__chunk{i:02d}.txt"
                  cp.write_text(part, encoding="utf-8")
                  manifest.append({"file": p.as_posix(), "chunk": i, "chunk_count": len(parts),
                                   "chunk_path": cp.as_posix(), "est_tokens": est_tokens(part),
                                   "est_tokens_total": est_tokens(text)})
          
          batches = []
          for f in sorted(set(c["file"] for c in manifest)):
              chs = sorted([c for c in manifest if c["file"] == f], key=lambda x: x["chunk"])
              batch, batch_tok, batch_idx = [], 0, 1
              for c in chs:
                  if batch and batch_tok + c["est_tokens"] > TARGET_BATCH:
                      batches.append({"file": f, "batch": batch_idx, "chunks": batch, "batch_est_tokens": batch_tok})
                      batch, batch_tok, batch_idx = [], 0, batch_idx + 1
                  batch.append({"chunk": c["chunk"], "chunk_count": c["chunk_count"], 
                                "chunk_path": c["chunk_path"], "est_tokens": c["est_tokens"]})
                  batch_tok += c["est_tokens"]
              if batch:
                  batches.append({"file": f, "batch": batch_idx, "chunks": batch, "batch_est_tokens": batch_tok})
          
          (outdir / "batches.json").write_text(json.dumps(batches, indent=2))
          print(f"Files: {len(files)}, Batches: {len(batches)}")
          PYTHONSCRIPT
          
          python3 .tmp_narrative_review/chunk.py

      - name: Run AI review
        if: steps.collect.outputs.has_files == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          MODEL: ${{ steps.model.outputs.model }}
          MAX_TOKENS: ${{ env.MAX_OUTPUT_TOKENS_PER_BATCH }}
          HAS_CANON: ${{ steps.canon.outputs.has_canon }}
        run: |
          PR="${{ github.event.pull_request.number }}"
          COMMENT=".tmp_narrative_review/review_comment.md"
          
          echo "<!-- NARRATIVE_REVIEW -->" > "$COMMENT"
          echo "# Narrative Review (AI)" >> "$COMMENT"
          echo "" >> "$COMMENT"
          echo "- Model: \`${MODEL}\`" >> "$COMMENT"
          echo "- PR: #${PR}" >> "$COMMENT"
          if [ "$HAS_CANON" = "true" ]; then
            echo "- Canon-Kontext: ✅ Aktiv" >> "$COMMENT"
          fi
          echo "" >> "$COMMENT"
          
          BATCH_COUNT=$(jq 'length' .tmp_narrative_review/batches.json)
          
          for idx in $(seq 0 $((BATCH_COUNT-1))); do
            FILE=$(jq -r ".[$idx].file" .tmp_narrative_review/batches.json)
            BATCH=$(jq -r ".[$idx].batch" .tmp_narrative_review/batches.json)
            
            # Build content from chunks using temp file
            TEMPFILE=".tmp_narrative_review/batch_${idx}_content.txt"
            > "$TEMPFILE"
            
            CHUNK_COUNT=$(jq -r ".[$idx].chunks | length" .tmp_narrative_review/batches.json)
            for cidx in $(seq 0 $((CHUNK_COUNT-1))); do
              CPATH=$(jq -r ".[$idx].chunks[$cidx].chunk_path" .tmp_narrative_review/batches.json)
              CNUM=$(jq -r ".[$idx].chunks[$cidx].chunk" .tmp_narrative_review/batches.json)
              CTOT=$(jq -r ".[$idx].chunks[$cidx].chunk_count" .tmp_narrative_review/batches.json)
              echo "" >> "$TEMPFILE"
              echo "---" >> "$TEMPFILE"
              echo "[CHUNK ${CNUM}/${CTOT}]" >> "$TEMPFILE"
              echo "" >> "$TEMPFILE"
              cat "$CPATH" >> "$TEMPFILE"
            done
            
            # Build enhanced prompt (NO MARKDOWN ASTERISKS - YAML syntax issue!)
            PROMPT_TEMP=".tmp_narrative_review/prompt_${idx}.txt"
            cat > "$PROMPT_TEMP" << 'PROMPTEOF'
Du bist der Lead Story Editor für MystiMons, ein deutsches YA-Fantasy-Franchise.

DEINE AUFGABE:
Reviewe den folgenden Text auf:
1. Canon-Konsistenz (gegen Pillars & Laws prüfen)
2. Narrative Qualität (Struktur, Pacing, Emotion)
3. YA-Voice Authentizität (14-jähriger Protagonist Finn)
4. Worldbuilding-Kohärenz (Magiesystem, Terminologie)

PROJEKT-KONTEXT:
- Franchise: MystiMons (YA Fantasy + TCG + App)
- Buch 1: "Aetheria: Der Klang der Stille"
- Protagonist: Finn Alder, 14 Jahre
  * Kann ALLE Resonanten hören (einzigartige Gabe)
  * Kann sich mit KEINEM binden (sein Fluch)
  * Sucht seinen verschwundenen Bruder Theo
- Kernbotschaft: "Du wirst nicht stärker allein. Du wirst stärker zusammen."
- Zielgruppe: 12-18 Jahre (Kern)

PROMPTEOF

            # Add Canon-Digest if available
            if [ "$HAS_CANON" = "true" ]; then
              cat >> "$PROMPT_TEMP" << 'CANONEOF'

CANON-REGELN (UNVERHANDELBAR):

CANONEOF
              cat .tmp_canon_digest.txt >> "$PROMPT_TEMP"
            fi

            # Add review structure
            cat >> "$PROMPT_TEMP" << 'STRUCTEOF'

REVIEW-STRUKTUR (PFLICHT):

Strukturiere dein Review EXAKT so:

1) Kurzfazit
Ein knapper Absatz: Was funktioniert? Was ist das Kernproblem?

2) BLOCKER (Dinge, die vor dem Schreiben geklärt/behoben werden müssen)
- Aufzählungsliste
- Jeder Punkt: Was ist das Problem? Warum blockiert es?
- Wenn gegen Pillars/Laws verstößt: Explizit benennen (z.B. "Verstößt gegen PIL-001")

3) WICHTIG (Wichtige Verbesserungen, die die Szenen deutlich stärker machen)
- Aufzählungsliste
- Konkrete Verbesserungsvorschläge
- Priorisiert nach Impact

4) NITPICK (Stil- und Detailanmerkungen)
- Aufzählungsliste
- Feinschliff, nicht kritisch
- Wortwahl, Tempo, kleine Inkonsistenzen

5) Fragen (für Autor/Worldbuilder)
- Nummerierte Liste
- Klärungsfragen zu Worldbuilding, Charaktermotivation, etc.
- Helfen, Plot-Holes zu vermeiden

Schlussbemerkung (kurz):
Gesamteindruck + nächste Schritte

REVIEW-KRITERIEN:

Canon-Konsistenz:
- Prüfe JEDEN Plot-Punkt gegen die 5 Pillars
- Prüfe gegen die 10 Laws
- Terminology-Check (Naming Bible)

YA-Voice (Finn, 14):
- Authentisch, nicht kindisch
- Innerer Monolog: reflektiert, manchmal unsicher
- Humor: trocken, nicht albern
- Zeigen statt Erzählen (keine Filterworte: "er fühlte")

Narrative Qualität:
- Szenenstruktur: Ziel → Konflikt → Veränderung
- Pacing: Wechsel zwischen Action und Reflexion
- Emotionale Stakes: Klar und nachvollziehbar
- Hooks: Kapitelenden ziehen weiter

Worldbuilding:
- Magiesystem-Regeln konsistent?
- Resonanz-Mechanik klar?
- Gesellschafts-Logik plausibel?

STRUCTEOF

            # Add file info and content
            echo "" >> "$PROMPT_TEMP"
            echo "---" >> "$PROMPT_TEMP"
            echo "" >> "$PROMPT_TEMP"
            echo "DATEI: ${FILE} (Batch ${BATCH})" >> "$PROMPT_TEMP"
            echo "" >> "$PROMPT_TEMP"
            echo "ZU REVIEWENDER TEXT:" >> "$PROMPT_TEMP"
            echo "" >> "$PROMPT_TEMP"
            cat "$TEMPFILE" >> "$PROMPT_TEMP"
            
            CONTENT=$(cat "$PROMPT_TEMP")
            
            PAYLOAD=$(jq -n \
              --arg m "$MODEL" \
              --arg content "$CONTENT" \
              --argjson maxtok "$MAX_TOKENS" \
              '{model:$m, input:[{role:"user",content:[{type:"input_text",text:$content}]}], max_output_tokens:$maxtok}')
            
            RESP=$(curl -w "\n%{http_code}" -sS \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -H "Content-Type: application/json" \
              https://api.openai.com/v1/responses \
              -d "$PAYLOAD")
            
            HTTP_CODE=$(echo "$RESP" | tail -1)
            BODY=$(echo "$RESP" | sed '$d')
            
            if [ "$HTTP_CODE" -ge 400 ]; then
              ERR=$(echo "$BODY" | jq -r '.error.message // "Unknown error"')
              echo "" >> "$COMMENT"
              echo "## ${FILE} — Batch ${BATCH}" >> "$COMMENT"
              echo "" >> "$COMMENT"
              echo "**Error** (HTTP ${HTTP_CODE}): ${ERR}" >> "$COMMENT"
              continue
            fi
            
            OUT=$(echo "$BODY" | jq -r '[.output[]? | select(.type=="message") | .content[]? | select(.type=="output_text") | .text] | join("\n\n")')
            
            STATUS=$(echo "$BODY" | jq -r '.status // "complete"')
            if [ "$STATUS" = "incomplete" ]; then
              REASON=$(echo "$BODY" | jq -r '.incomplete_details.reason // "unknown"')
              echo "" >> "$COMMENT"
              echo "## ${FILE} — Batch ${BATCH}" >> "$COMMENT"
              echo "" >> "$COMMENT"
              echo "> ⚠️ **Response incomplete** (reason: ${REASON})" >> "$COMMENT"
              echo "" >> "$COMMENT"
              echo "$OUT" >> "$COMMENT"
            else
              echo "" >> "$COMMENT"
              echo "## ${FILE} — Batch ${BATCH}" >> "$COMMENT"
              echo "" >> "$COMMENT"
              echo "$OUT" >> "$COMMENT"
            fi
          done

      - name: Post comment
        if: steps.collect.outputs.has_files == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR="${{ github.event.pull_request.number }}"
          REPO="${{ github.repository }}"
          FILE=".tmp_narrative_review/review_comment.md"
          
          [ ! -f "$FILE" ] && exit 0
          
          BODY=$(cat "$FILE")
          
          EXISTING=$(gh api "repos/$REPO/issues/$PR/comments" --paginate | jq -r '.[] | select(.body | contains("<!-- NARRATIVE_REVIEW -->")) | .id' | head -1 || true)
          
          PAYLOAD=$(jq -n --arg body "$BODY" '{body:$body}')
          
          if [ -n "$EXISTING" ]; then
            gh api -X PATCH "repos/$REPO/issues/comments/$EXISTING" --input - <<< "$PAYLOAD"
          else
            gh api -X POST "repos/$REPO/issues/$PR/comments" --input - <<< "$PAYLOAD"
          fi
